requirements.txt:
python-multipart==0.0.6
fastapi==0.95.0
uvicorn==0.21.1
psycopg2-binary==2.9.6
requests==2.28.2 

wait-for-db.sh:
#!/bin/bash
set -e

host="$1"
shift
cmd="$@"

until pg_isready -h "$host" -U postgres; do
  >&2 echo "Postgres is unavailable - sleeping"
  sleep 1
done

>&2 echo "Postgres is up - executing command"
exec $cmd


Dockerfile:
FROM python:3.10-slim

# Install required system dependencies
RUN apt-get update && apt-get install -y git ffmpeg postgresql-client

WORKDIR /app

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --upgrade pip && pip install -r requirements.txt

# Clone the markitdown repository and install it
RUN git clone https://github.com/microsoft/markitdown.git /tmp/markitdown
RUN pip install -e /tmp/markitdown/packages/markitdown[all]

# Copy the wait-for-db script
COPY wait-for-db.sh /app/wait-for-db.sh
RUN chmod +x /app/wait-for-db.sh

# Copy the entire app folder
COPY . .

# Expose FastAPIâ€™s port
EXPOSE 5000

# Use wait-for-db.sh to ensure the database is up, then start Uvicorn
CMD ["/app/wait-for-db.sh", "db", "uvicorn", "app.main:app", "--host=0.0.0.0", "--port=5000"]


docker-compose.yml:
version: '3'
services:
  web:
    build: .
    container_name: intel-man
    ports:
      - "5001:5000"
    volumes:
      - .:/app
    environment:
      - DATABASE_URL=postgresql://postgres:your_password@db:5432/your_db_name
    depends_on:
      - db

  db:
    image: postgres:15.3
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: your_password
      POSTGRES_DB: your_db_name
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./db-init:/docker-entrypoint-initdb.d

volumes:
  pgdata:


/app/services.py:
from fastapi import HTTPException, UploadFile
from typing import Optional, List
import os
import requests
import psycopg2
from psycopg2.extras import RealDictCursor
from psycopg2 import sql

# Import your config constants
from .config import STORAGE_FOLDER, DATABASE_URL



###############################################################################
# BROWSE SERVICES
###############################################################################
def get_files_from_db():
    # ... your logic for listing from the database
    # e.g., read from intel_L100_files table and return a list
    # something like:
    conn = psycopg2.connect(DATABASE_URL)
    cur = conn.cursor(cursor_factory=RealDictCursor)
    cur.execute("SELECT * FROM intel_l100_files") 
    files = cur.fetchall()
    ...
    return {"files": files}

def list_files_service():
    """
    Return a list of files in the storage folder.
    """
    if not os.path.exists(STORAGE_FOLDER):
        return {"files": []}
    files = [
        f for f in os.listdir(STORAGE_FOLDER)
        if os.path.isfile(os.path.join(STORAGE_FOLDER, f))
    ]
    return {"files": files}

def download_file_service(filename: str):
    """
    Return a FileResponse for downloading a file by its name.
    (Note: Usually you'd return fastapi.responses.FileResponse here,
    but if you're doing it from the router, you can do that in the router function.)
    """
    file_path = os.path.join(STORAGE_FOLDER, filename)
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    return file_path  # Let the router wrap this in FileResponse

def get_file_details_service(file_id: int):
    """
    Retrieve a single file record by its file_id from the intel_l100_files table.
    """
    import psycopg2
    from psycopg2.extras import RealDictCursor
    from fastapi import HTTPException
    from .config import DATABASE_URL

    conn = None
    try:
        conn = psycopg2.connect(DATABASE_URL)
        with conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("SELECT * FROM intel_l100_files WHERE file_id = %s", (file_id,))
            file_record = cur.fetchone()
            if not file_record:
                raise HTTPException(status_code=404, detail="File not found")
            return file_record
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        if conn:
            conn.close()
###############################################################################
# UPLOAD SERVICES
###############################################################################
def process_upload_service(file: UploadFile):
    """
    Handle uploading file, saving it, converting to markdown, updating DB.
    """
    if not file or not file.filename:
        raise HTTPException(status_code=400, detail="No file uploaded")

    # We do an async read here, but let's simplify to synchronous for demonstration.
    # If you prefer the fully async read, you can handle that in the router itself.
    try:
        original_filename = file.filename
        _, ext = os.path.splitext(original_filename)

        create_user = "test_user"  # or from token in real usage
        status = "uploaded"

        # Insert a new record to get the file_id
        file_id = insert_file_record(create_user, original_filename, status)
        new_filename = f"{file_id}{ext}"
        new_file_path = os.path.join(STORAGE_FOLDER, new_filename)

        # Ensure storage folder exists
        os.makedirs(STORAGE_FOLDER, exist_ok=True)

        # Save the file to disk
        content = file.file.read()  # Synchronous read
        with open(new_file_path, "wb") as f:
            f.write(content)

        # Convert to markdown
        markdown_content = convert_file_to_markdown(new_file_path)

        # Update the DB record
        update_file_record(file_id, new_filename, markdown_content)

        return {
            "record_id": file_id,
            "allocated_filename": new_filename,
            "markdown": markdown_content
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing upload: {e}")

###############################################################################
# HELPER FUNCTIONS FOR UPLOAD SERVICE
###############################################################################
def convert_file_to_markdown(file_path: str, enable_plugins: bool = False) -> str:
    """
    Convert a file to Markdown using MarkItDown or any library you like.
    """
    from markitdown import MarkItDown
    md = MarkItDown(enable_plugins=enable_plugins)
    result = md.convert(file_path)
    return result.text_content

def insert_file_record(create_user, uploaded_file_name, status):
    """
    Insert a record into intel_L100_files table.
    """
    conn = None
    try:
        conn = psycopg2.connect(DATABASE_URL)
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO intel_L100_files (create_user, uploaded_file_name, file_name, status)
                VALUES (%s, %s, %s, %s)
                RETURNING file_id;
            """, (create_user, uploaded_file_name, "placeholder", status))
            file_id = cur.fetchone()[0]
        conn.commit()
        return file_id
    except Exception as e:
        if conn:
            conn.rollback()
        raise e
    finally:
        if conn:
            conn.close()

def update_file_record(file_id, file_name, markdown_extract):
    """
    Update the file record with the allocated file name and markdown content.
    """
    conn = None
    try:
        conn = psycopg2.connect(DATABASE_URL)
        with conn.cursor() as cur:
            cur.execute("""
                UPDATE intel_L100_files
                SET file_name = %s,
                    markdown_extract = %s,
                    metad_create_date = CURRENT_TIMESTAMP,
                    metad_edit_date = CURRENT_TIMESTAMP
                WHERE file_id = %s;
            """, (file_name, markdown_extract, file_id))
        conn.commit()
    except Exception as e:
        if conn:
            conn.rollback()
        raise e
    finally:
        if conn:
            conn.close()

###############################################################################
# LLM SERVICE
###############################################################################
def query_llm_service(prompt: Optional[str], messages: Optional[List[dict]]):
    """
    Send a request to your LLM backend and return the JSON response.
    """
    if not prompt and not messages:
        raise HTTPException(status_code=400, detail="No prompt or messages provided")

    # Build messages array
    if messages:
        final_messages = messages
    else:
        final_messages = [{"role": "user", "content": prompt}]

    api_url = ""  # Your real LLM endpoint
    headers = {
        "Content-Type": "application/json",
        "api-key": ""
    }
    payload = {
        "messages": final_messages,
        "max_completion_tokens": 5000,
        "reasoning_effort": "high"
    }

    try:
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"LLM request failed: {str(e)}")

###############################################################################
# DB EXPLORER SERVICES
###############################################################################
def list_tables_service():
    """
    Return a list of table names from the public schema.
    """
    conn = None
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
        """)
        tables = [row["table_name"] for row in cur.fetchall()]
        cur.close()
        return {"tables": tables}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        if conn:
            conn.close()

def get_table_snapshot_service(table_name: str):
    """
    Return columns and up to 10 rows from a named table.
    """
    conn = None
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cur = conn.cursor(cursor_factory=RealDictCursor)

        # Validate table
        cur.execute("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = %s;
        """, (table_name,))
        if not cur.fetchone():
            raise HTTPException(status_code=404, detail="Table not found")

        query = sql.SQL("SELECT * FROM {} LIMIT 10;").format(sql.Identifier(table_name))
        cur.execute(query)
        records = cur.fetchall()

        columns = [desc.name for desc in cur.description] if cur.description else []
        cur.close()

        return {"columns": columns, "records": records}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        if conn:
            conn.close()


/app/config.py:
import os

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
STORAGE_FOLDER = os.path.join(BASE_DIR, 'storage')
DATABASE_URL = os.environ.get('DATABASE_URL', f"sqlite:///{os.path.join(BASE_DIR, 'app.db')}")

# New entries for authentication.
SECRET_KEY = "your_secret_key_here"  # Remember to use a secure key in production.
ALGORITHM = "HS256"


/app/routing.py:
from fastapi import APIRouter, File, UploadFile, Depends, HTTPException, Response, Request, Form
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from typing import Optional, List

from .services import *

router = APIRouter()

async def same_origin_only(request: Request):
    """Block requests unless they come from the same origin as the server itself."""
    server_host = request.url.netloc
    request_host = request.headers.get("host", "")
    if request_host.lower() == server_host.lower():
        return
    else:
        raise HTTPException(status_code=403, detail="Cross-origin requests are not allowed.")


# ---------------------------
# LOGIN ENDPOINT
# ---------------------------
@router.post("/api/login/login")
async def login(username: str = Form(...), password: str = Form(...)):
    if username == "test_user" and password == "dlpi":
        response = JSONResponse({"access_token": "valid_token", "redirect_url": "/index.html"})
        response.set_cookie(key="access_token", value="valid_token", httponly=True)
        return response
    else:
        return JSONResponse({"detail": "Invalid credentials"}, status_code=400)
    
# ---------------------------
# BROWSE ENDPOINTS
# ---------------------------
@router.get("/api/browse/db", dependencies=[Depends(same_origin_only)])
def get_files():
    return get_files_from_db()

@router.get("/api/browse/folder", dependencies=[Depends(same_origin_only)])
def get_files_folder():
    return list_files_service()

@router.get("/api/browse/download/{filename}", dependencies=[Depends(same_origin_only)])
def download_file(filename: str):
    file_path = download_file_service(filename)
    return FileResponse(file_path, media_type="application/octet-stream", filename=filename)

@router.get("/api/file/{file_id}")
def get_file_details(file_id: int):
    """
    Return the file details for a given file_id.
    """
    return get_file_details_service(file_id)

# ---------------------------
# UPLOAD ENDPOINT
# ---------------------------
@router.post("/api/upload/", dependencies=[Depends(same_origin_only)])
async def upload_file(file: UploadFile = File(...)):
    return process_upload_service(file)

# ---------------------------
# LLM ENDPOINT
# ---------------------------
class LLMRequest(BaseModel):
    prompt: Optional[str] = None
    messages: Optional[List[dict]] = None

@router.post("/api/llm/", dependencies=[Depends(same_origin_only)])
def query_llm(data: LLMRequest):
    return query_llm_service(data.prompt, data.messages)

# ---------------------------
# DB EXPLORER ENDPOINTS
# ---------------------------
@router.get("/api/dbexplorer/tables", dependencies=[Depends(same_origin_only)])
def list_tables():
    return list_tables_service()

@router.get("/api/dbexplorer/table/{table_name}", dependencies=[Depends(same_origin_only)])
def get_table_snapshot(table_name: str):
    return get_table_snapshot_service(table_name)

/app/main.py:
# /app/main.py

from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse
from starlette.staticfiles import StaticFiles

from .routing import router

app = FastAPI(title="My FastAPI App")

# Include your routers.
app.include_router(router)

# Serve static files (including your login page, index.html, etc.)
app.mount("/", StaticFiles(directory="app/static", html=True), name="static")

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # Define a list of public paths that don't require authentication.
    public_paths = [
        "/login.html",      # Login page
        "/api/login/login"  # Login API endpoint
    ]
    # Allow access to static assets and documentation endpoints without auth.
    if request.url.path.startswith("/static"):
        return await call_next(request)

    # If the request path is public, bypass authentication.
    if request.url.path in public_paths:
        return await call_next(request)

    # Check if the access_token cookie is set.
    token = request.cookies.get("access_token")
    if not token:
        # Redirect to the login page if the token is missing.
        return RedirectResponse(url="/login.html")

    # Otherwise, continue processing the request.
    response = await call_next(request)
    return response


/app/static/index.html:
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Home - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>
  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>
  

  <div class="container mt-5" id="homeApp">
    <h1>Welcome to My App</h1>
    <p>This is the home page served by FastAPI static hosting.</p>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({}).mount('#homeApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/.DS_Store:
Error reading file: 'utf-8' codec can't decode byte 0x86 in position 23: invalid start byte

/app/static/browse.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Browse Files - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>
  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>

  <div class="container mt-5" id="browseApp">
    <h1>File manager</h1>
    <hr>

    <!-- Upload Section -->
    
    <div class="mb-3">
      <table class="table table-sm table-borderless">
        <tr>
          <td width="1%" nowrap><p class="mt-2">Upload new file</p></td>
          <td><input type="file" class="form-control" @change="onFileChange"></td>
          <td width="1%"><button class="btn btn-primary" @click="uploadFile" :disabled="!selectedFile">Upload</button></td>
        </tr>
      </table>
      <p class="text-success" v-if="uploadResult">Upload Result:{{ uploadResult }}</p>
      <p class="alert alert-danger" v-if="uploadError">{{ uploadError }}</p>
      
    </div>
    
    <hr>

    <!-- Option Buttons to switch listing mode -->
    <div class="mb-3">
      <button class="btn btn-primary me-2" @click="useDB = true">List from DB</button>
      <button class="btn btn-secondary" @click="useDB = false">List from Folder</button>
    </div>
    
    <!-- Table for DB-based listing -->
    <table v-if="useDB" class="table table-striped">
      <thead>
        <tr>
          <th>File ID</th>
          <th>Uploaded By</th>
          <th>Original Name</th>
          <th>Stored Name</th>
          <th>Status</th>
          <th>Actions</th>
          <th>Link</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="file in files" :key="file.file_id">
          <td>{{ file.file_id }}</td>
          <td>{{ file.create_user }}</td>
          <td>{{ file.uploaded_file_name }}</td>
          <td>{{ file.file_name }}</td>
          <td>{{ file.status }}</td>
          <td>
            <!-- Instead of a plain anchor, use a button that calls downloadFile -->
            <button class="btn btn-sm btn-primary" @click="downloadFile(file.file_name)">
              Download
            </button>
          </td>
          <td><a :href="`/file.html?file_id=${file.file_id}`" class="btn btn-sm btn-primary">View Details</a></td>
        </tr>
        <tr v-if="files.length === 0">
          <td colspan="6" class="text-center">No files recorded in DB.</td>
        </tr>
      </tbody>
    </table>

    <!-- List for folder-based listing -->
    <ul v-else class="list-group">
      <li class="list-group-item" v-for="file in files" :key="file">
        {{ file }}
        <button class="btn btn-sm btn-primary float-end" @click="downloadFile(file)">
          Download
        </button>
      </li>
      <li class="list-group-item" v-if="files.length === 0">No files in folder.</li>
    </ul>

  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          files: [],
          useDB: true,  // true for DB listing, false for folder listing
          selectedFile: null,
          uploadResult: '',
          uploadError: ''
        }
      },
      methods: {
        fetchFiles() {
          const endpoint = this.useDB ? '/api/browse/db' : '/api/browse/folder';
          
          fetch(endpoint)
            .then(response => {
              if (!response.ok) {
                throw new Error("Failed to fetch files.");
              }
              return response.json();
            })
            .then(data => {
              // The API should return data.files as either an array of objects or filenames.
              this.files = data.files;
            })
            .catch(error => {
              console.error('Error fetching files:', error);
              this.uploadError = 'Error fetching files: ' + error.message;
            });
        },
        onFileChange(event) {
          this.selectedFile = event.target.files[0];
        },
        async uploadFile() {
          if (!this.selectedFile) {
            this.uploadError = 'Please select a file.';
            return;
          }
          this.uploadError = '';
          const formData = new FormData();
          formData.append('file', this.selectedFile);
          try {
            const response = await fetch('/api/upload/', {
              method: 'POST',
              body: formData
            });
            const data = await response.json();
            if (response.ok) {
              // Assume API returns a field named "markdown" as the upload result.
              this.uploadResult = "Successfully uploaded with ID:"+data.record_id;
              // Refresh the file list after a successful upload.
              this.fetchFiles();
            } else {
              this.uploadError = data.detail || 'Upload failed.';
            }
          } catch (err) {
            console.error('Upload error:', err);
            this.uploadError = 'An error occurred during upload.';
          }
        },
        downloadFile(fileName) {
          fetch(`/api/browse/download/${fileName}`)
          .then(response => {
            if (!response.ok) {
              throw new Error("Failed to download file.");
            }
            return response.blob();
          })
          .then(blob => {
            // Create a temporary link to download the file
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            // Use fileName or a more descriptive file name if available
            link.setAttribute('download', fileName);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);
          })
          .catch(error => {
            console.error('Download error:', error);
            alert('Error downloading file: ' + error.message);
          });
        }
      },
      watch: {
        // Refetch files whenever the listing mode (DB vs folder) changes.
        useDB() {
          this.fetchFiles();
        }
      },
      mounted() {
        this.fetchFiles();
      }
    }).mount('#browseApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/documents.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Upload - My App</title>
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico">


  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>

  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>

  <div class="container mt-5" id="documentsApp">
    <h1>Document manager</h1>
    
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          file: null,
          result: '',
          error: ''
        }
      },
      methods: {
        onFileChange(event) {
          this.file = event.target.files[0];
        },
        async uploadFile() {
          if (!this.file) {
            this.error = 'Please select a file.';
            return;
          }
          this.error = '';
          const formData = new FormData();
          formData.append('file', this.file);
          try {
            const response = await fetch('/api/upload/', {
              method: 'POST',
              body: formData
            });
            const data = await response.json();
            if (response.ok) {
              // 'markdown' is returned by the API
              this.result = data.markdown;
            } else {
              this.error = data.error || 'Upload failed';
            }
          } catch (err) {
            console.error('Upload error:', err);
            this.error = 'An error occurred while uploading.';
          }
        }
      }
    }).mount('#documentsApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/login.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Login - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>

  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">My App</a>
    </div>
  </nav>

  <div class="container mt-5" id="loginApp">
    <div class="row">
      <div class="col-6 mx-auto">

        <h2>Login</h2>
        <div class="alert alert-danger" v-if="error">{{ error }}</div>
    
        <!-- Wrap fields and button in a form and use @submit.prevent -->
        <form @submit.prevent="attemptLogin">
          <!-- Hidden username field -->
          <input type="hidden" class="form-control" id="username" v-model="username">
    
          <div class="mb-3">
            <label for="password" class="form-label">Password</label>
            <input 
              type="password" 
              class="form-control" 
              id="password" 
              v-model="password" 
              placeholder="Enter your password"
            >
          </div>
    
          <!-- Button now a submit button -->
          <button type="submit" class="btn btn-outline-dark float-end">Login</button>
        </form>
      </div>
    </div>
    
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          username: '', // not shown in UI, but still stored here
          password: '',
          error: ''
        }
      },
      mounted() {
        // Hardcode the username right away, or do it in attemptLogin
        this.username = 'test_user';
      },
      methods: {
        async attemptLogin() {
          const formData = new URLSearchParams();
          formData.append('username', this.username);
          formData.append('password', this.password);

          try {
            const response = await fetch('/api/login/login', {
              method: 'POST',
              credentials: 'same-origin',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              body: formData
            });
            const data = await response.json();
            if (response.ok) {
              localStorage.setItem('access_token', data.access_token);
              window.location.href = 'index.html';
              const data = await response.json();
              window.location.href = data.redirect_url;
            } else {
              this.error = data.detail || 'Login failed.';
            }
          } catch (err) {
            console.error(err);
            this.error = 'An error occurred while logging in.';
          }
        }
      }
    }).mount('#loginApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/dbexplorer.html:
<!-- /app/static/dbexplorer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Database Explorer - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>

  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>

  <div class="container mt-5" id="dbExplorerApp">
    <h1>Database Explorer</h1>
    
    <!-- Button to refresh table list -->
    <button class="btn btn-secondary mb-3" @click="fetchTables">Refresh Tables</button>
    
    <h2>Tables</h2>
    <ul class="list-group mb-4">
      <li 
        class="list-group-item list-group-item-action" 
        v-for="(table, index) in tables" 
        :key="index"
        @click="fetchTableSnapshot(table)"
        style="cursor: pointer;"
      >
        {{ table }}
      </li>
      <li class="list-group-item" v-if="tables.length === 0">
        No tables found.
      </li>
    </ul>

    <!-- Table Snapshot Section -->
    <div v-if="selectedTable">
      <h2>Snapshot of Table: <em>{{ selectedTable }}</em></h2>
      <table class="table table-striped" v-if="tableSnapshot.records.length > 0">
        <thead>
          <tr>
            <th v-for="col in tableSnapshot.columns" :key="col">{{ col }}</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="(row, index) in tableSnapshot.records" :key="index">
            <td v-for="col in tableSnapshot.columns" :key="col">{{ row[col] }}</td>
          </tr>
        </tbody>
      </table>
      <div v-else>
        <p>No records found in this table.</p>
      </div>
    </div>

    <!-- Error message -->
    <div class="alert alert-danger" v-if="error">{{ error }}</div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          tables: [],
          selectedTable: '',
          tableSnapshot: {
            columns: [],
            records: []
          },
          error: ''
        }
      },
      methods: {
        fetchTables() {
          this.error = '';
          this.tables = [];
          fetch('/api/dbexplorer/tables')
            .then(resp => {
              if (!resp.ok) {
                throw new Error("Failed to fetch tables.");
              }
              return resp.json();
            })
            .then(data => {
              this.tables = data.tables || [];
            })
            .catch(err => {
              console.error(err);
              this.error = 'Error fetching table list.';
            });
        },
        fetchTableSnapshot(table) {
          this.error = '';
          this.selectedTable = table;
          this.tableSnapshot = { columns: [], records: [] };
          fetch(`/api/dbexplorer/table/${table}`)
            .then(resp => {
              if (!resp.ok) {
                throw new Error("Failed to fetch table snapshot.");
              }
              return resp.json();
            })
            .then(data => {
              this.tableSnapshot = data;
            })
            .catch(err => {
              console.error(err);
              this.error = 'Error fetching table snapshot.';
            });
        }
      },
      mounted() {
        this.fetchTables();
      }
    }).mount('#dbExplorerApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/file.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>File Details - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
  <!-- Include markdown-it library -->
  <script src="js/markdown-it.min.js"></script>
</head>
<body>
  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>

  <div class="container mt-5" id="fileApp">
    <h1>File Details</h1>
    <hr>
    
    <div v-if="error">
      <p class="text-danger">{{ error }}</p>
    </div>
    
    <div v-else-if="file">
      <div class="row">
        <!-- Left Pane: File details without Markdown -->
        <div class="col-md-4">
            <h4>IntelMan details</h4>
            <hr>
            <p><strong>File ID:</strong> {{ file.file_id }}</p>
            <p><strong>Stored Filename:</strong> {{ file.file_name }}</p>
            <p><strong>Status:</strong> {{ file.status }}</p>

            <h4>
                Internal document details
                <button class="btn btn-outline-dark"
                    @click="scrapeMetadata">Scrape</button>

            </h4>
            <p><strong>Description:</strong> {{ file.description }}</p>
            <p><strong>File Description:</strong> {{ file.file_description }}</p>
            <p><strong>Author:</strong> {{ file.author }}</p>
            <p><strong>Title:</strong> {{ file.title }}</p>
            <p><strong>Version:</strong> {{ file.version }}</p>
            
            <h4>Document</h4>
            <p><strong>Doc ID:</strong> {{ file.doc_id }}</p>
            <p><strong>Owner:</strong> {{ file.owner }}</p>
            <p><strong>Fingerprint:</strong> {{ file.fingerprint }}</p>
            

            <h4>Metadata</h4>
            <p><strong>Uploaded Filename:</strong> {{ file.uploaded_file_name }}</p>
            <p><strong>Created:</strong> {{ file.metad_create_date }}</p>
            <p><strong>Last Updated:</strong> {{ file.metad_edit_date }}</p>
        </div>


        <!-- Right Pane: Parsed Markdown -->
        <div class="col-md-8">
            <h4>Extracted content</h4>
            <hr>
            <div v-if="renderedMarkdown" v-html="renderedMarkdown"></div>
            <div v-else>
                <p>No markdown available.</p>
            </div>
        </div>
      </div>
    </div>
    
    <div v-else>
      <p>Loading file details...</p>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          fileId: 0,
          file: null,
          error: ''
        }
      },
      // The computed property uses markdown-it to parse the markdown_extract
      computed: {
        renderedMarkdown() {
          if (this.file && this.file.markdown_extract) {
            const md = window.markdownit();
            return md.render(this.file.markdown_extract);
          }
          return '';
        }
      },
      methods: {
        fetchFileDetails() {
          fetch(`/api/file/${this.fileId}`)
          .then(response => {
            if (!response.ok) {
              throw new Error("Failed to fetch file details.");
            }
            return response.json();
          })
          .then(data => {
            this.file = data;
          })
          .catch(err => {
            console.error(err);
            this.error = 'Error fetching file details.';
          });
        },
        fetchInternalFileDetails() {
          fetch(`/api/file/${this.fileId}`)
          .then(response => {
            if (!response.ok) {
              throw new Error("Failed to fetch file details.");
            }
          })
        },
        async scrapeMetadata() {
          
          this.error = '';
          this.metadata = null;
          try {
            if (!token) {
              this.error = 'You must be logged in to scrape metadata.';
              return;
            }
            const response = await fetch(`/api/scrape/scrape/${this.fileId}`, {
              method: 'POST',
            });
            const data = await response.json();
            if (response.ok) {
              this.metadata = data.metadata;
            } else {
              this.error = data.detail || 'Scraping failed.';
            }
          } catch (err) {
            console.error(err);
            this.error = 'An error occurred while scraping metadata.';
          }
        }
      },
      mounted() {
        // Parse file_id from the URL query parameters (e.g., file.html?file_id=1)
        const urlParams = new URLSearchParams(window.location.search);
        this.fileId = urlParams.get('file_id');
        if (this.fileId) {
          this.fetchFileDetails();
        } else {
          this.error = 'No file ID specified in the URL.';
        }
      }
    }).mount('#fileApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/llm.html:
<!-- app/static/llm.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chat with LLM - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>
  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>

  <div class="container mt-5" id="chatApp">
    <h1>Chat with LLM</h1>
    <div id="conversation" style="max-height: 400px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;">
      <div v-for="(message, index) in messages" :key="index" :class="{'text-end': message.role === 'assistant'}">
        <p><strong>{{ message.role }}:</strong> {{ message.content }}</p>
      </div>
    </div>

    <div class="mt-3">
      <input type="text" v-model="newPrompt" class="form-control" placeholder="Type your message">
    </div>
    <div class="mt-2">
      <button class="btn btn-primary" @click="sendMessage" :disabled="!newPrompt">Send</button>
    </div>

    <div class="mt-3" v-if="error">
      <div class="alert alert-danger" role="alert">{{ error }}</div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          messages: [],
          newPrompt: '',
          error: ''
        }
      },
      methods: {
        async sendMessage() {
          // add user prompt to conversation
          this.messages.push({ role: 'user', content: this.newPrompt });
          const payload = { messages: this.messages };
          try {
            const response = await fetch('/api/llm/', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            const data = await response.json();
            if (response.ok) {
              // If your API returns something like data.choices[0].message:
              if (data.choices && data.choices.length > 0) {
                const assistantMsg = data.choices[0].message;
                this.messages.push(assistantMsg);
              } else {
                this.error = 'No response received from LLM.';
              }
            } else {
              this.error = data.error || 'LLM request failed.';
            }
          } catch (err) {
            console.error('LLM request error:', err);
            this.error = 'An error occurred while sending your message.';
          }
          this.newPrompt = '';
        }
      }
    }).mount('#chatApp');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/events.html:
<!-- app/static/events.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Events - My App</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/vue.global.js"></script>
</head>
<body>
  <div id="menu"></div>
  <script type="module">
    import { renderMenu } from './js/menu.js';
    renderMenu();
  </script>

  <div class="container mt-5" id="eventBrowser">
    <h1>Event History Browser</h1>
    <!-- Add your event-browsing UI or logic here -->
  </div>

  <script>
    const { createApp } = Vue;
    createApp({}).mount('#eventBrowser');
  </script>
  <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>


/app/static/css/bootstrap.min.css:
[Library file content skipped]

/app/static/images/favicon.ico:
Error reading file: 'utf-8' codec can't decode byte 0x96 in position 50: invalid start byte

/app/static/js/bootstrap.bundle.min.js:
[Library file content skipped]

/app/static/js/vue.global.js:
[Library file content skipped]

/app/static/js/menu.js:
[Library file content skipped]

/app/static/js/markdown-it.min.js:
[Library file content skipped]

/db-init/init.sql:
CREATE TABLE IF NOT EXISTS intel_l100_files (
  file_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  uploaded_file_name VARCHAR(255) NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_description TEXT,
  doc_id INTEGER, -- This is a foreign key; update the reference if you have a series table
  fingerprint VARCHAR(255),
  description TEXT,
  metad_create_date TIMESTAMP,
  metad_edit_date TIMESTAMP,
  markdown_extract TEXT,
  title VARCHAR(255),
  version VARCHAR(50),
  author VARCHAR(255),
  owner VARCHAR(255),
  status VARCHAR(255)
  -- Uncomment and adjust the next line if you have a referenced table for file_series:
  --, FOREIGN KEY (file_series) REFERENCES file_series(file_series_id)
);



-- Table: intel_l101_docs
-- Columns: doc_id, create_date, create_user, delete_date, delete_user, doc_name,
--          doc_desc, doc_author, doc_owner, owner_group_id, doc_weights
CREATE TABLE IF NOT EXISTS intel_l101_docs (
  doc_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  doc_name VARCHAR(255) NOT NULL,
  doc_desc TEXT,
  doc_author VARCHAR(255),
  doc_owner VARCHAR(50),
  owner_group_id INTEGER,
  doc_weights JSONB
  -- If you later decide on a foreign key:
  --, FOREIGN KEY (owner_group_id) REFERENCES intel_l102_group(group_id)
);

---------------------------------------------------------------------------
-- Table: intel_l102_group
-- Columns: group_id, create_date, create_user, delete_date, delete_user, group_name, group_desc
CREATE TABLE IF NOT EXISTS intel_l102_group (
  group_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  group_name VARCHAR(255) NOT NULL,
  group_desc TEXT
);

---------------------------------------------------------------------------
-- Table: intel_l103_group_users
-- Columns: group_user_id, create_date, create_user, delete_date, delete_user,
--          group_id, user_id, expiry_date
CREATE TABLE IF NOT EXISTS intel_l103_group_users (
  group_user_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  group_id INTEGER NOT NULL,
  user_id INTEGER NOT NULL,
  expiry_date TIMESTAMP
  -- Optionally, add foreign keys once the reference tables exist:
  --, FOREIGN KEY (group_id) REFERENCES intel_l102_group(group_id)
  --, FOREIGN KEY (user_id) REFERENCES users(user_id)
);

---------------------------------------------------------------------------
-- Table: intel_l104_group_docs
-- Columns: group_doc_id, create_date, create_user, delete_date, delete_user,
--          group_id, doc_id, expiry_date
CREATE TABLE IF NOT EXISTS intel_l104_group_docs (
  group_doc_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  group_id INTEGER NOT NULL,
  doc_id INTEGER NOT NULL,
  expiry_date TIMESTAMP
  --, FOREIGN KEY (group_id) REFERENCES intel_l102_group(group_id)
  --, FOREIGN KEY (doc_id) REFERENCES intel_l101_docs(doc_id)
);

---------------------------------------------------------------------------
-- Table: intel_l105_models
-- Columns: model_id, create_date, create_user, delete_date, delete_user,
--          model_file_name, model_desc
CREATE TABLE IF NOT EXISTS intel_l105_models (
  model_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  model_file_name VARCHAR(255) NOT NULL,
  model_desc TEXT
);

---------------------------------------------------------------------------
-- Table: intel_l106_deployments
-- Columns: deployment_id, create_date, create_user, delete_date, delete_user,
--          owner_group_id, model_id, deployment_name, deployment_desc
CREATE TABLE IF NOT EXISTS intel_l106_deployments (
  deployment_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  owner_group_id INTEGER,
  model_id INTEGER NOT NULL,
  deployment_name VARCHAR(255) NOT NULL,
  deployment_desc TEXT
  --, FOREIGN KEY (owner_group_id) REFERENCES intel_l102_group(group_id)
  --, FOREIGN KEY (model_id) REFERENCES intel_l105_models(model_id)
);

---------------------------------------------------------------------------
-- Table: intel_l107_deployment_docs
-- Columns: deployment_doc_id, create_date, create_user, delete_date, delete_user,
--          deployment_id, doc_id
CREATE TABLE IF NOT EXISTS intel_l107_deployment_docs (
  deployment_doc_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  deployment_id INTEGER NOT NULL,
  doc_id INTEGER NOT NULL
  --, FOREIGN KEY (deployment_id) REFERENCES intel_l106_deployments(deployment_id)
  --, FOREIGN KEY (doc_id) REFERENCES intel_l101_docs(doc_id)
);

---------------------------------------------------------------------------
-- Table: intel_L200_process
-- Columns: process_id, create_date, create_user, delete_date, delete_user,
--          group_id, process_name, process_desc
CREATE TABLE IF NOT EXISTS intel_L200_process (
  process_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  group_id INTEGER,  -- For access control; can reference intel_l102_group(group_id)
  process_name VARCHAR(255) NOT NULL,
  process_desc TEXT
  --, FOREIGN KEY (group_id) REFERENCES intel_l102_group(group_id)
);

---------------------------------------------------------------------------
-- Table: intel_L201_process_steps
-- Columns: step_id, create_date, create_user, delete_date, delete_user,
--          process_id, step_desc, step_action, parameter_one, parameter_two
CREATE TABLE IF NOT EXISTS intel_L201_process_steps (
  step_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  process_id INTEGER NOT NULL,
  step_desc TEXT,
  step_action VARCHAR(255),
  parameter_one TEXT,
  parameter_two TEXT
  --, FOREIGN KEY (process_id) REFERENCES intel_L200_process(process_id)
);

---------------------------------------------------------------------------
-- Table: intel_L210_interaction
-- Columns: interaction_id, create_date, create_user, delete_date, delete_user,
--          process_id, current_step_id
CREATE TABLE IF NOT EXISTS intel_L210_interaction (
  interaction_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  process_id INTEGER NOT NULL,
  current_step_id INTEGER
  --, FOREIGN KEY (process_id) REFERENCES intel_L200_process(process_id)
  --, FOREIGN KEY (current_step_id) REFERENCES intel_L201_process_steps(step_id)
);

---------------------------------------------------------------------------
-- Table: intel_L211_working_notes
-- Columns: workings_id, create_date, create_user, delete_date, delete_user,
--          interaction_id, working_notes
CREATE TABLE IF NOT EXISTS intel_L211_working_notes (
  workings_id SERIAL PRIMARY KEY,
  create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  create_user VARCHAR(50) NOT NULL,
  delete_date TIMESTAMP,
  delete_user VARCHAR(50),
  interaction_id INTEGER NOT NULL,
  working_notes TEXT
  --, FOREIGN KEY (interaction_id) REFERENCES intel_L210_interaction(interaction_id)
);


